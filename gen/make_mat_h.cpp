#include <cstring>
#include <fstream>
#include <functional>
#include <iostream>
#include <string>
#include <sstream>
#include <type_traits>

#define VERSION "3.1.1"

namespace data
{
    const struct {std::string tag, name;} type_list[]
    {
        "b",   "bool",
        "c",   "char",
        "uc",  "unsigned char",
        "sc",  "signed char",
        "s",   "short",
        "us",  "unsigned short",
        "i",   "int",
        "u",   "unsigned int",
        "l",   "long",
        "ul",  "unsigned long",
        "ll",  "long long",
        "ull", "unsigned long long",
        "f",   "float",
        "d",   "double",
        "ld",  "long double",
        "i8",  "int8_t",
        "u8",  "uint8_t",
        "i16", "int16_t",
        "u16", "uint16_t",
        "i32", "int32_t",
        "u32", "uint32_t",
        "i64", "int64_t",
        "u64", "uint64_t",
    };
    constexpr int type_list_len = std::extent_v<decltype(type_list)>;

    const std::string fields[4] {"x","y","z","w"};
    constexpr int fields_alt_count = 2;
    const std::string fields_alt[fields_alt_count][4]
    {
        fields[0], fields[1], fields[2], fields[3],
        "r","g","b","a",
        // "s","t","p","q", // Who uses this anyway.
    };
}

namespace impl
{
    std::ofstream output_file("mat.h");

    std::stringstream ss;
    const std::stringstream::fmtflags stdfmt = ss.flags();

    bool at_line_start = 1;
    int indentation = 0;
    int section_depth = 0;

    constexpr const char *indentation_string = "    ";
}

template <typename ...P> [[nodiscard]] std::string make_str(const P &... params)
{
    impl::ss.clear();
    impl::ss.str("");
    impl::ss.flags(impl::stdfmt);
    (impl::ss << ... << params);
    return impl::ss.str();
}

void output_str(const std::string &str)
{
    for (const char *ptr = str.c_str(); *ptr; ptr++)
    {
        char ch = *ptr;

        if (ch == '}' && impl::indentation > 0)
            impl::indentation--;

        if (impl::at_line_start)
        {
            if (std::strchr(" \t\r", ch))
                continue;

            for (int i = 0; i < impl::indentation; i++)
                impl::output_file << impl::indentation_string;
            impl::at_line_start = 0;
        }

        impl::output_file.put(ch == '$' ? ' ' : ch);

        if (ch == '{')
            impl::indentation++;

        if (ch == '\n')
            impl::at_line_start = 1;
    }
}

template <typename ...P> void output(const P &... params)
{
    output_str(make_str(params...));
}

void section(std::string header, std::function<void()> func)
{
    output(header, "\n{\n");
    func();
    output("}\n");
}
void section_sc(std::string header, std::function<void()> func) // 'sc' stands for 'end with semicolon'
{
    output(header, "\n{\n");
    func();
    output("};\n");
}

void decorative_section(std::string name, std::function<void()> func)
{
    output("//{", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation--;
    impl::section_depth++;
    func();
    impl::section_depth--;
    output("//}", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation++;
}

void next_line()
{
    output("\n");
}

int main()
{
    if (!impl::output_file)
        return -1;

    { // Header
        output(1+R"(
            // mat.h
            // Vector and matrix math
            // Version )", VERSION, R"(
            // Autogenerated, don't touch.

            #pragma once
        )");
        next_line();
    }

    { // Includes
        output(1+R"(
            #include <algorithm>
            #include <cmath>
            #include <cstddef>
            #include <cstdint>
            #include <istream>
            #include <ostream>
            #include <tuple>
            #include <type_traits>
            #include <utility>
        )");
        next_line();
    }

    section("namespace Math", []
    {
        section("inline namespace Vector // Declarations", []
        {
            { // Main templates
                output(1+R"(
                    template <int D, typename T> struct vec;
                    template <int W, int H, typename T> struct mat;
                )");
            }

            { // Type-generic
                // Vectors of specific size
                for (int i = 2; i <= 4; i++)
                    output(" template <typename T> using vec", i, " = vec<", i, ",T>;");
                next_line();

                // Matrices of specific size
                for (int h = 2; h <= 4; h++)
                {
                    for (int w = 2; w <= 4; w++)
                        output(" template <typename T> using mat", w, "x", h, " = mat<", w, ",", h, ",T>;");
                    next_line();
                }

                // Square matrices of specific size
                for (int i = 2; i <= 4; i++)
                    output(" template <typename T> using mat", i, " = mat", i, "x", i, "<T>;");
                next_line();
            }
            next_line();

            { // Size-generic
                for (int i = 0; i < data::type_list_len; i++)
                {
                    const auto &type = data::type_list[i];

                    // Any size
                    output("template <int D> using ", type.tag, "vec = vec<D,", type.name, ">;\n"
                           "template <int W, int H> using ", type.tag, "mat = mat<W,H,", type.name, ">;\n");

                    // Fixed size
                    for (int d = 2; d <= 4; d++)
                        output(" using ", type.tag, "vec", d, " = vec<", d, ',', type.name, ">;");
                    next_line();
                    for (int h = 2; h <= 4; h++)
                    {
                        for (int w = 2; w <= 4; w++)
                            output(" using ", type.tag, "mat", w, "x", h, " = mat<", w, ",", h, ",", type.name, ">;");
                        next_line();
                    }
                    for (int i = 2; i <= 4; i++)
                        output(" using ", type.tag, "mat", i, " = ", type.tag, "mat", i, "x", i, ";");
                    next_line();

                    if (i != data::type_list_len-1)
                        next_line();
                }
            }
        });

        next_line();

        section("inline namespace Utility // Templates", []
        {
            output(1+R"(
                template <typename T> struct is_vector_impl : std::false_type {};
                template <int D, typename T> struct is_vector_impl<      vec<D,T>> : std::true_type {};
                template <int D, typename T> struct is_vector_impl<const vec<D,T>> : std::true_type {};
                template <typename T> inline constexpr bool is_vector_v = is_vector_impl<T>::value;

                template <typename ...P> inline constexpr bool no_vectors_v = !(is_vector_v<P> || ...);

                template <typename T> struct is_matrix_impl : std::false_type {};
                template <int W, int H, typename T> struct is_matrix_impl<mat<W,H,T>> : std::true_type {};
                template <int W, int H, typename T> struct is_matrix_impl<const mat<W,H,T>> : std::true_type {};
                template <typename T> inline constexpr bool is_matrix_v = is_matrix_impl<T>::value;

                template <typename T> inline constexpr bool is_scalar_v = !is_vector_v<T> && !is_matrix_v<T>;

                template <typename A, typename B = void> using enable_if_scalar_t = std::enable_if_t<is_scalar_v<A>, B>;

                template <typename T> using vec_base_t = typename std::conditional_t<is_vector_v<T>, T, std::enable_if<1,T>>::type;

                template <typename T> struct vec_size_impl : std::integral_constant<int, 1> {};
                template <int D, typename T> struct vec_size_impl<      vec<D,T>> : std::integral_constant<int, D> {};
                template <int D, typename T> struct vec_size_impl<const vec<D,T>> : std::integral_constant<int, D> {};
                template <typename T> inline constexpr int vec_size_v = vec_size_impl<T>::value;

                template <typename A, typename B> using change_vec_base_t = std::conditional_t<is_vector_v<A>, vec<vec_size_v<A>, B>, B>;

                template <typename T> using floating_point_t = std::conditional_t<std::is_floating_point_v<vec_base_t<T>>, T, change_vec_base_t<T, double>>;

                template <typename A, typename B> inline constexpr int compare_types_v =
                $   (!is_scalar_v<A> && !is_vector_v<A>) || (!is_scalar_v<B> && !is_vector_v<B>) ? 0 :
                $   std::is_floating_point_v<vec_base_t<A>> < std::is_floating_point_v<vec_base_t<B>> ? -1 :
                $   std::is_floating_point_v<vec_base_t<A>> > std::is_floating_point_v<vec_base_t<B>> ?  1 :
                $   sizeof(vec_base_t<A>)                   < sizeof(vec_base_t<B>)                   ? -1 :
                $   sizeof(vec_base_t<A>)                   > sizeof(vec_base_t<B>)                   ?  1 : 0;

                template <typename ...P> struct larger_impl {using type = void;};
                template <typename T> struct larger_impl<T> {using type = T;};
                template <typename T, typename ...P> struct larger_impl<T,P...> {using type = typename larger_impl<T, typename larger_impl<P...>::type>::type;};
                template <typename A, typename B> struct larger_impl<A,B> {using type = std::conditional_t<compare_types_v<A,B> != 0, std::conditional_t<(compare_types_v<A,B> > 0), A, B>, std::conditional_t<std::is_same_v<A,B>, A, void>>;};
                template <int D, typename A, typename B> struct larger_impl<vec<D,A>,B> {using type = std::conditional_t<std::is_void_v<typename larger_impl<A,B>::type>, void, change_vec_base_t<vec<D,A>, typename larger_impl<A,B>::type>>;};
                template <int D, typename A, typename B> struct larger_impl<B,vec<D,A>> {using type = std::conditional_t<std::is_void_v<typename larger_impl<A,B>::type>, void, change_vec_base_t<vec<D,A>, typename larger_impl<A,B>::type>>;};
                template <int DA, int DB, typename A, typename B> struct larger_impl<vec<DA,A>,vec<DB,B>>
                {using type = std::conditional_t<DA != DB || std::is_void_v<typename larger_impl<A,B>::type>, void, change_vec_base_t<vec<DA,A>, typename larger_impl<A,B>::type>>;};

                // Void on failure
                template <typename ...P> struct opt_larger_impl {using type = typename larger_impl<std::remove_const_t<P>...>::type;};
                template <typename ...P> using opt_larger_t = typename opt_larger_impl<P...>::type; // void on failure

                template <typename ...P> inline constexpr bool have_larger_type_v = !std::is_void_v<opt_larger_t<P...>>;

                // Soft error on failure
                template <typename ...P> using soft_larger_t = std::enable_if_t<have_larger_type_v<P...>, opt_larger_t<P...>>;

                template <typename ...P> struct hard_larger_impl
                {
                    static_assert(have_larger_type_v<P...>, "Can't determine larger type.");
                    using type = opt_larger_t<P...>;
                };

                // Hard error on failure
                template <typename ...P> using larger_t = typename hard_larger_impl<P...>::type;
            )");
        });

        next_line();

        section("inline namespace Vector // Definitions", []
        {
            decorative_section("Vectors", [&]
            {
                for (int w = 2; w <= 4; w++)
                {
                    if (w != 2)
                        next_line();

                    section_sc(make_str("template <typename T> struct vec<",w,",T> // vec",w), [&]
                    {
                        auto Fields = [&](std::string fold_op, std::string pre = "", std::string post = "") -> std::string
                        {
                            std::string ret;
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    ret += fold_op;
                                ret += pre + data::fields[i] + post;
                            }
                            return ret;
                        };

                        { // Static assertions
                            output("static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, \"The base type must have no cv-qualifiers.\");\n");
                            output("static_assert(!std::is_reference_v<T>, \"The base type must not be a reference.\");\n");
                        }

                        { // Aliases
                            output("using type = T;\n");
                        }

                        { // Properties
                            output("static constexpr int size = ",w,";\n");
                            output("static constexpr bool is_floating_point = std::is_floating_point_v<type>;\n");
                        }

                        { // Members
                            for (int i = 0; i < w; i++)
                            {
                                output("union {type ");
                                for (int j = 0; j < data::fields_alt_count; j++)
                                {
                                    if (j != 0)
                                        output(", ");
                                    output(data::fields_alt[j][i]);
                                }
                                output(";};\n");
                            }
                        }

                        { // Constructors
                            // Default
                            output("constexpr vec() = default;\n");

                            // Element-wise
                            output("constexpr vec(",Fields(", ","type "),") : ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(data::fields[i],"(",data::fields[i],")");
                            }
                            output(" {}\n");

                            // Fill with a single value
                            output("explicit constexpr vec(type obj) : ",Fields(", ","", "(obj)")," {}\n");

                            // Converting
                            output("template <typename TT> constexpr vec(vec",w,"<TT> obj) : ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(data::fields[i],"(obj.",data::fields[i],")");
                            }
                            output(" {}\n");
                        }

                        { // Convert to type
                            output("template <typename TT> [[nodiscard]] constexpr vec",w,"<TT> to() const {return vec",w,"<TT>(",Fields(", ", "TT(", ")"),");}\n");
                        }

                        { // Member access
                            // Operator []
                            output("[[nodiscard]] constexpr type &operator[](int i) {return *(type *)((char *)this + sizeof(type)*i);}\n");
                            output("[[nodiscard]] constexpr const type &operator[](int i) const {return *(type *)((char *)this + sizeof(type)*i);}\n");

                            // As array
                            output("[[nodiscard]] type *as_array() {return &x;};\n");
                            output("[[nodiscard]] const type *as_array() const {return &x;};\n");
                        }

                        { // Boolean
                            // Convert to bool
                            output("[[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, \"Use .none(), .any(), or .all() for vectors/matrices of bool.\");}\n");

                            // None of
                            output("[[nodiscard]] constexpr bool none() const {return !this->any();}\n");

                            // Any of
                            output("[[nodiscard]] constexpr bool any() const {return ",Fields(" || "),";}\n");

                            // All of
                            output("[[nodiscard]] constexpr bool all() const {return ",Fields(" && "),";}\n");
                        }

                        { // Apply operators
                            // Sum
                            output("[[nodiscard]] constexpr auto sum() const {return ", Fields(" + "), ";}\n");

                            // Product
                            output("[[nodiscard]] constexpr auto prod() const {return ", Fields(" * "), ";}\n");

                            // Ratio
                            if (w == 2)
                                output("[[nodiscard]] constexpr auto ratio() const {return ", Fields(" / ","floating_point_t<type>(",")"), ";}\n");

                            // Min
                            output("[[nodiscard]] constexpr type min() const {return std::min({", Fields(","), "});}\n");
                            // Max
                            output("[[nodiscard]] constexpr type max() const {return std::max({", Fields(","), "});}\n");

                            // Abs
                            output("[[nodiscard]] constexpr vec abs() const {return vec(", Fields(", ", "std::abs(", ")"), ");}\n");
                        }

                        { // Copy with modified members
                            struct Operator
                            {
                                std::string name, str;
                            };
                            const Operator operators[]{{"set",""},{"add","+"},{"sub","-"},{"mul","*"},{"div","/"}};

                            for (const auto &op : operators)
                            for (int i = 0; i < data::fields_alt_count; i++)
                            {
                                for (int j = 0; j < w; j++)
                                {
                                    bool op_set = op.str == "";
                                    output(" template <typename N> [[nodiscard]] constexpr ",(op_set ? "vec" : "auto")," ",op.name,"_",data::fields_alt[i][j],"(N n) const {return ",
                                           (op_set ? "vec" : make_str("vec",w,"<decltype(x",op.str,"n)>")),"(");
                                    for (int k = 0; k < w; k++)
                                    {
                                        if (k != 0)
                                            output(", ");
                                        if (k == j)
                                            output(op_set ? "n" : data::fields_alt[i][k] + op.str + "n");
                                        else
                                            output(data::fields_alt[i][k]);
                                    }
                                    output(");}");
                                }
                                next_line();
                            }
                        }

                        { // Resize
                            for (int i = 2; i <= 4; i++)
                            {
                                if (i == w)
                                    continue;
                                output("[[nodiscard]] constexpr vec",i,"<type> to_vec",i,"(");
                                for (int j = w; j < i; j++)
                                {
                                    if (j != w)
                                        output(", ");
                                    output("type n",data::fields[j]);
                                }
                                output(") const {return {");
                                for (int j = 0; j < i; j++)
                                {
                                    if (j != 0)
                                        output(", ");
                                    if (j >= w)
                                        output("n");
                                    output(data::fields[j]);
                                }
                                output("};}\n");
                            }
                            for (int i = w+1; i <= 4; i++)
                            {
                                output("[[nodiscard]] constexpr vec",i,"<type> to_vec",i,"() const {return to_vec",i,"(");
                                for (int j = w; j < i; j++)
                                {
                                    if (j != w)
                                        output(", ");
                                    output("01"[j == 3]);
                                }
                                output(");}\n");
                            }
                        }

                        { // Length and normalization
                            // Squared length
                            output("[[nodiscard]] constexpr auto len_sqr() const {return ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(" + ");
                                output(data::fields[i],"*",data::fields[i]);
                            }
                            output(";}\n");

                            // Length
                            output("[[nodiscard]] constexpr auto len() const {return std::sqrt(len_sqr());}\n");

                            // Normalize
                            output("[[nodiscard]] constexpr auto norm() const -> vec",w,"<decltype(type{}/len())> {if (auto l = len(); l != 0) return *this / l; else return vec(0);}\n");
                        }

                        { // Angles and directions
                            if (w == 2)
                            {
                                // Construct from angle
                                output("template <typename TT> [[nodiscard]] static constexpr vec dir(TT angle, type len = 1) {return vec(std::cos(angle) * len, std::sin(angle) * len); static_assert(is_floating_point, \"The vector must be floating-point.\");}\n");

                                // Get angle
                                output("template <typename TT = double> [[nodiscard]] constexpr T angle() const {return std::atan2(TT(y), TT(x));}\n"); // Note that atan2 is well-defined even when applied to (0,0).

                                // Rotate by 90 degree increments
                                output("[[nodiscard]] constexpr vec rot90(int steps = 1) const {switch (steps & 3) {default: return *this; case 1: return {-y,x}; case 2: return -*this; case 3: return {y,-x};}}\n");
                            }
                        }

                        { // Dot and cross products
                            // Dot product
                            output("template <typename TT> [[nodiscard]] constexpr auto dot(const vec",w,"<TT> &o) const {return ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(" + ");
                                output(data::fields[i]," * o.",data::fields[i]);
                            }
                            output(";}\n");

                            // Cross product
                            if (w == 3)
                                output("template <typename TT> [[nodiscard]] constexpr auto cross(const vec3<TT> &o) const -> vec3<decltype(x * o.x - x * o.x)> {return {y * o.z - z * o.y, z * o.x - x * o.z, x * o.y - y * o.x};}\n");

                            // Cross product z component
                            if (w == 2)
                                output("template <typename TT> [[nodiscard]] constexpr auto cross(const vec2<TT> &o) const {return x * o.y - y * o.x;}\n");

                            // Delta (aka inverse minus)
                            output("template <typename TT> [[nodiscard]] constexpr auto delta(vec",w,"<TT> v) const {return v - *this;}\n");
                        }

                        { // Tie
                            output("[[nodiscard]] constexpr auto tie() {return std::tie(",Fields(","),");}\n");
                            output("[[nodiscard]] constexpr auto tie() const {return std::tie(",Fields(","),");}\n");
                        }

                        { // Get
                            output("template <int I> [[nodiscard]] constexpr auto &get() {return std::get<I>(tie());}\n");
                            output("template <int I> [[nodiscard]] constexpr auto &get() const {return std::get<I>(tie());}\n");
                        }
                    });
                }

                next_line();

                // Deduction guides
                output("template <typename ...P, typename = std::enable_if_t<sizeof...(P) >= 2 && sizeof...(P) <= 4>> vec(P...) -> vec<sizeof...(P), larger_t<P...>>;\n");
            });

            next_line();

            decorative_section("Matrices", [&]
            {
                for (int w = 2; w <= 4; w++)
                for (int h = 2; h <= 4; h++)
                {
                    if (w != 2 || h != 2)
                        next_line();

                    section_sc(make_str("template <typename T> struct mat<",w,",",h,",T> // mat", w, "x", h), [&]
                    {
                        auto LargeFields = [&](std::string fold_op, std::string pre = "", std::string post = "") -> std::string
                        {
                            std::string ret;
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    ret += fold_op;
                                ret += pre + data::fields[i] + post;
                            }
                            return ret;
                        };
                        auto SmallFields = [&](std::string fold_op, std::string pre = "", std::string post = "", std::string mid = ".") -> std::string
                        {
                            std::string ret;
                            for (int y = 0; y < h; y++)
                            for (int x = 0; x < w; x++)
                            {
                                if (x != 0 || y != 0)
                                    ret += fold_op;
                                ret += pre + data::fields[x] + mid + data::fields[y] + post;
                            }
                            return ret;
                        };

                        { // Static assertions
                            output("static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, \"The base type must have no cv-qualifiers.\");\n");
                            output("static_assert(!std::is_reference_v<T>, \"The base type must not be a reference.\");\n");
                        }

                        { // Aliases
                            output("using type = T;\n");
                            output("using member_type = vec", h,"<T>;\n");
                        }

                        { // Properties
                            output("static constexpr int width = ",w,", height = ",h,";\n");
                            if (w == h)
                                output("static constexpr int size = ",w,";\n");

                            output("static constexpr bool is_floating_point = std::is_floating_point_v<type>;\n");
                        }

                        { // Members
                            for (int i = 0; i < w; i++)
                            {
                                output("union {member_type ");
                                for (int j = 0; j < data::fields_alt_count; j++)
                                {
                                    if (j != 0)
                                        output(", ");
                                    output(data::fields_alt[j][i]);
                                }
                                output(";};\n");
                            }
                        }

                        { // Constructors
                            // Default
                            output("constexpr mat() : mat(");
                            for (int y = 0; y < h; y++)
                            for (int x = 0; x < w; x++)
                            {
                                if (x || y)
                                    output(",");
                                output("01"[x == y]);
                            }
                            output(") {}\n");

                            // Element-wise
                            output("constexpr mat(",LargeFields(", ","const member_type &"),") : ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(data::fields[i],"(",data::fields[i],")");
                            }
                            output(" {}\n");

                            // Matrix element-wise
                            output("constexpr mat(",SmallFields(", ","type ","",""),") : ");
                            for (int x = 0; x < w; x++)
                            {
                                if (x != 0)
                                    output(", ");
                                output(data::fields[x],"(");
                                for (int y = 0; y < h; y++)
                                {
                                    if (y != 0)
                                        output(",");
                                    output(data::fields[x],data::fields[y]);
                                }
                                output(")");
                            }
                            output(" {}\n");

                            // Converting
                            output("template <typename TT> constexpr mat(const mat",w,"x",h,"<TT> &obj) : ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(data::fields[i],"(obj.",data::fields[i],")");
                            }
                            output(" {}\n");
                        }

                        { // Convert to type
                            output("template <typename TT> [[nodiscard]] constexpr mat",w,"x",h,"<TT> to() const {return mat",w,"x",h,"<TT>(",SmallFields(", ","TT(",")"),");}\n");
                        }

                        { // Member access
                            // Operator []
                            output("[[nodiscard]] constexpr member_type &operator[](int i) {return *(member_type *)((char *)this + sizeof(member_type)*i);}\n");
                            output("[[nodiscard]] constexpr const member_type &operator[](int i) const {return *(member_type *)((char *)this + sizeof(member_type)*i);}\n");

                            // As array
                            output("[[nodiscard]] type *as_array() {return &x.x;};\n");
                            output("[[nodiscard]] const type *as_array() const {return &x.x;};\n");
                        }

                        { // Resize
                            // One-dimensional
                            for (int i = 2; i <= 4; i++)
                            {
                                if (i == w)
                                    continue;
                                output("[[nodiscard]] constexpr mat",i,"x",h,"<type> to_vec",i,"(");
                                for (int j = w; j < i; j++)
                                {
                                    if (j != w)
                                        output(", ");
                                    output("const member_type &n",data::fields[j]);
                                }
                                output(") const {return {");
                                for (int j = 0; j < i; j++)
                                {
                                    if (j != 0)
                                        output(", ");
                                    if (j >= w)
                                        output("n");
                                    output(data::fields[j]);
                                }
                                output("};}\n");
                            }
                            for (int i = w+1; i <= 4; i++)
                            {
                                output("[[nodiscard]] constexpr mat",i,"x",h,"<type> to_vec",i,"() const {return to_vec",i,"(");
                                for (int j = w; j < i; j++)
                                {
                                    if (j != w)
                                        output(", ");
                                    output("{}");
                                }
                                output(");}\n");
                            }

                            // Two-dimensional
                            for (int hhh = 2; hhh <= 4; hhh++)
                            {
                                for (int www = 2; www <= 4; www++)
                                {
                                    if (www == w && hhh == h)
                                        continue;
                                    output("[[nodiscard]] constexpr mat",www,"x",hhh,"<type> to_mat",www,"x",hhh,"() const {return {");
                                    for (int hh = 0; hh < hhh; hh++)
                                    {
                                        for (int ww = 0; ww < www; ww++)
                                        {
                                            if (ww != 0 || hh != 0)
                                                output(",");
                                            if (ww < w && hh < h)
                                                output(data::fields[ww],".",data::fields[hh]);
                                            else
                                                output("01"[ww == hh]);
                                        }
                                    }
                                    output("};}\n");
                                    if (www == hhh)
                                        output("[[nodiscard]] constexpr mat",www,"x",hhh,"<type> to_mat",www,"() const {return to_mat",www,"x",www,"();}\n");
                                }
                            }
                        }

                        { // Transpose
                            output("[[nodiscard]] constexpr mat",h,"x",w,"<T> transpose() const {return {");
                            for (int x = 0; x < w; x++)
                            for (int y = 0; y < h; y++)
                            {
                                if (x != 0 || y != 0)
                                    output(",");
                                output(data::fields[x],".",data::fields[y]);
                            }
                            output("};}\n");
                        }

                        { // Inverse
                            if (w == h)
                            {
                                // NOTE: `ret{}` is used instead of `ret`, because otherwise those functions wouldn't be constexpr due to an uninitialized variable.

                                switch (w)
                                {
                                  case 2:
                                    output(1+R"(
                                        [[nodiscard]] constexpr mat inverse()
                                        {
                                            static_assert(is_floating_point, "This function only makes sense for floating-point matrices.");

                                            mat ret{};

                                            ret.x.x =  y.y;
                                            ret.y.x = -y.x;

                                            type d = x.x * ret.x.x + x.y * ret.y.x;
                                            if (d == 0) return {};
                                            d = 1 / d;
                                            ret.x.x *= d;
                                            ret.y.x *= d;

                                            ret.x.y = (-x.y) * d;
                                            ret.y.y = ( x.x) * d;

                                            return ret;
                                        }
                                    )");
                                    break;
                                  case 3:
                                    output(1+R"(
                                        [[nodiscard]] constexpr mat inverse() const
                                        {
                                            static_assert(is_floating_point, "This function only makes sense for floating-point matrices.");

                                            mat ret{};

                                            ret.x.x =  y.y * z.z - z.y * y.z;
                                            ret.y.x = -y.x * z.z + z.x * y.z;
                                            ret.z.x =  y.x * z.y - z.x * y.y;

                                            type d = x.x * ret.x.x + x.y * ret.y.x + x.z * ret.z.x;
                                            if (d == 0) return {};
                                            d = 1 / d;
                                            ret.x.x *= d;
                                            ret.y.x *= d;
                                            ret.z.x *= d;

                                            ret.x.y = (-x.y * z.z + z.y * x.z) * d;
                                            ret.y.y = ( x.x * z.z - z.x * x.z) * d;
                                            ret.z.y = (-x.x * z.y + z.x * x.y) * d;
                                            ret.x.z = ( x.y * y.z - y.y * x.z) * d;
                                            ret.y.z = (-x.x * y.z + y.x * x.z) * d;
                                            ret.z.z = ( x.x * y.y - y.x * x.y) * d;

                                            return ret;
                                        }
                                    )");
                                    break;
                                  case 4:
                                    output(1+R"(
                                        [[nodiscard]] constexpr mat inverse() const
                                        {
                                            static_assert(is_floating_point, "This function only makes sense for floating-point matrices.");

                                            mat ret;

                                            ret.x.x =  y.y * z.z * w.w - y.y * z.w * w.z - z.y * y.z * w.w + z.y * y.w * w.z + w.y * y.z * z.w - w.y * y.w * z.z;
                                            ret.y.x = -y.x * z.z * w.w + y.x * z.w * w.z + z.x * y.z * w.w - z.x * y.w * w.z - w.x * y.z * z.w + w.x * y.w * z.z;
                                            ret.z.x =  y.x * z.y * w.w - y.x * z.w * w.y - z.x * y.y * w.w + z.x * y.w * w.y + w.x * y.y * z.w - w.x * y.w * z.y;
                                            ret.w.x = -y.x * z.y * w.z + y.x * z.z * w.y + z.x * y.y * w.z - z.x * y.z * w.y - w.x * y.y * z.z + w.x * y.z * z.y;

                                            type d = x.x * ret.x.x + x.y * ret.y.x + x.z * ret.z.x + x.w * ret.w.x;
                                            if (d == 0) return {};
                                            d = 1 / d;
                                            ret.x.x *= d;
                                            ret.y.x *= d;
                                            ret.z.x *= d;
                                            ret.w.x *= d;

                                            ret.x.y = (-x.y * z.z * w.w + x.y * z.w * w.z + z.y * x.z * w.w - z.y * x.w * w.z - w.y * x.z * z.w + w.y * x.w * z.z) * d;
                                            ret.y.y = ( x.x * z.z * w.w - x.x * z.w * w.z - z.x * x.z * w.w + z.x * x.w * w.z + w.x * x.z * z.w - w.x * x.w * z.z) * d;
                                            ret.z.y = (-x.x * z.y * w.w + x.x * z.w * w.y + z.x * x.y * w.w - z.x * x.w * w.y - w.x * x.y * z.w + w.x * x.w * z.y) * d;
                                            ret.w.y = ( x.x * z.y * w.z - x.x * z.z * w.y - z.x * x.y * w.z + z.x * x.z * w.y + w.x * x.y * z.z - w.x * x.z * z.y) * d;
                                            ret.x.z = ( x.y * y.z * w.w - x.y * y.w * w.z - y.y * x.z * w.w + y.y * x.w * w.z + w.y * x.z * y.w - w.y * x.w * y.z) * d;
                                            ret.y.z = (-x.x * y.z * w.w + x.x * y.w * w.z + y.x * x.z * w.w - y.x * x.w * w.z - w.x * x.z * y.w + w.x * x.w * y.z) * d;
                                            ret.z.z = ( x.x * y.y * w.w - x.x * y.w * w.y - y.x * x.y * w.w + y.x * x.w * w.y + w.x * x.y * y.w - w.x * x.w * y.y) * d;
                                            ret.w.z = (-x.x * y.y * w.z + x.x * y.z * w.y + y.x * x.y * w.z - y.x * x.z * w.y - w.x * x.y * y.z + w.x * x.z * y.y) * d;
                                            ret.x.w = (-x.y * y.z * z.w + x.y * y.w * z.z + y.y * x.z * z.w - y.y * x.w * z.z - z.y * x.z * y.w + z.y * x.w * y.z) * d;
                                            ret.y.w = ( x.x * y.z * z.w - x.x * y.w * z.z - y.x * x.z * z.w + y.x * x.w * z.z + z.x * x.z * y.w - z.x * x.w * y.z) * d;
                                            ret.z.w = (-x.x * y.y * z.w + x.x * y.w * z.y + y.x * x.y * z.w - y.x * x.w * z.y - z.x * x.y * y.w + z.x * x.w * y.y) * d;
                                            ret.w.w = ( x.x * y.y * z.z - x.x * y.z * z.y - y.x * x.y * z.z + y.x * x.z * z.y + z.x * x.y * y.z - z.x * x.z * y.y) * d;

                                            return ret;
                                        }
                                    )");
                                    break;
                                }
                            }
                        }

                        { // Matrix presets
                            auto MakePreset = [&](int min_sz, int max_sz, std::string name, std::string params, std::string param_names, std::string body, bool float_only = 1)
                            {
                                if (w != h)
                                    return;

                                if (w == min_sz)
                                {
                                    output("[[nodiscard]] static constexpr mat ",name,"(",params,")\n{\n");
                                    if (float_only)
                                        output("static_assert(is_floating_point, \"This function only makes sense for floating-point matrices.\");\n");
                                    output(body,"}\n");
                                }
                                else if (w >= min_sz && w <= max_sz)
                                {
                                    output("[[nodiscard]] static constexpr mat ",name,"(",params,") {return mat",min_sz,"<T>::",name,"(",param_names,").to_mat",w,"();}\n");
                                }
                            };

                            MakePreset(2, 3, "scale", "vec2<type> v", "v", 1+R"(
                                return { v.x , 0   ,
                                    $    0   , v.y };
                            )", 0);

                            MakePreset(3, 4, "scale", "vec3<type> v", "v", 1+R"(
                                return { v.x , 0   , 0   ,
                                    $    0   , v.y , 0   ,
                                    $    0   , 0   , v.z };
                            )", 0);

                            MakePreset(3, 3, "ortho", "vec2<type> min, vec2<type> max", "min, max", 1+R"(
                                return { 2 / (max.x - min.x) , 0                   , (min.x + max.x) / (min.x - max.x) ,
                                    $    0                   , 2 / (max.y - min.y) , (min.y + max.y) / (min.y - max.y) ,
                                    $    0                   , 0                   , 1                                 };
                            )");

                            MakePreset(4, 4, "ortho", "vec2<type> min, vec2<type> max, type near, type far", "min, max, near, far", 1+R"(
                                return { 2 / (max.x - min.x) , 0                   , 0                , (min.x + max.x) / (min.x - max.x) ,
                                    $    0                   , 2 / (max.y - min.y) , 0                , (min.y + max.y) / (min.y - max.y) ,
                                    $    0                   , 0                   , 2 / (near - far) , (near + far) / (near - far)       ,
                                    $    0                   , 0                   , 0                , 1                                 };
                            )");

                            MakePreset(4, 4, "look_at", "vec3<type> src, vec3<type> dst, vec3<type> local_up", "src, dst, local_up", 1+R"(
                                vec3<type> v3 = (src-dst).norm();
                                vec3<type> v1 = local_up.cross(v3).norm();
                                vec3<type> v2 = v3.cross(v1);
                                return { v1.x , v1.y , v1.z , -src.x*v1.x-src.y*v1.y-src.z*v1.z ,
                                    $    v2.x , v2.y , v2.z , -src.x*v2.x-src.y*v2.y-src.z*v2.z ,
                                    $    v3.x , v3.y , v3.z , -src.x*v3.x-src.y*v3.y-src.z*v3.z ,
                                    $    0    , 0    , 0    , 1                                 };
                            )");

                            MakePreset(3, 3, "translate", "vec2<type> v", "v", 1+R"(
                                return { 1, 0, v.x ,
                                    $    0, 1, v.y ,
                                    $    0, 0, 1   };
                            )", 0);

                            MakePreset(4, 4, "translate", "vec3<type> v", "v", 1+R"(
                                return { 1 , 0 , 0 , v.x ,
                                    $    0 , 1 , 0 , v.y ,
                                    $    0 , 0 , 1 , v.z ,
                                    $    0 , 0 , 0 , 1   };
                            )", 0);

                            MakePreset(2, 3, "rotate", "type angle", "angle", 1+R"(
                                type c = std::cos(angle);
                                type s = std::sin(angle);
                                return { c, -s ,
                                    $    s, c  };
                            )");

                            MakePreset(3, 4, "rotate_with_normalized_axis", "vec3<type> axis, type angle", "axis, angle", 1+R"(
                                type c = std::cos(angle);
                                type s = std::sin(angle);
                                return { axis.x * axis.x * (1 - c) + c          , axis.x * axis.y * (1 - c) - axis.z * s , axis.x * axis.z * (1 - c) + axis.y * s,
                                    $    axis.y * axis.x * (1 - c) + axis.z * s , axis.y * axis.y * (1 - c) + c          , axis.y * axis.z * (1 - c) - axis.x * s,
                                    $    axis.x * axis.z * (1 - c) - axis.y * s , axis.y * axis.z * (1 - c) + axis.x * s , axis.z * axis.z * (1 - c) + c         };
                            )", 0);
                            MakePreset(3, 4, "rotate", "vec3<type> axis, type angle", "axis, angle", 1+R"(
                                return rotate_with_normalized_axis(axis.norm(), angle);
                            )");

                            MakePreset(4, 4, "perspective", "type wh_aspect, type y_fov, type near, type far", "wh_aspect, y_fov, near, far", 1+R"(
                                y_fov = type(1) / std::tan(y_fov / 2);
                                return { y_fov / wh_aspect , 0     , 0                           , 0                             ,
                                    $    0                 , y_fov , 0                           , 0                             ,
                                    $    0                 , 0     , (near + far) / (near - far) , 2 * near * far / (near - far) ,
                                    $    0                 , 0     , -1                          , 0                             };
                            )");
                        }
                    });
                }

                next_line();

                // Deduction guides
                output("template <typename ...P, std::enable_if_t<sizeof...(P) == 4, bool> = true> mat(P...) -> mat<2, 2, larger_t<P...>>;\n");
                output("template <typename ...P, std::enable_if_t<sizeof...(P) == 9, bool> = true> mat(P...) -> mat<3, 3, larger_t<P...>>;\n");
                output("template <typename ...P, std::enable_if_t<sizeof...(P) == 16, bool> = true> mat(P...) -> mat<4, 4, larger_t<P...>>;\n");
            });

            next_line();

            decorative_section("Operators", []
            {
                const std::string
                    ops2[]{"+","-","*","/","%","^","&","|","<<",">>","<",">","<=",">=","==","!="},
                    ops2bool[]{"&&","||"},
                    ops1[]{"~","+","-"},
                    ops1incdec[]{"++","--"},
                    ops1bool[]{"!"},
                    ops2as[]{"+=","-=","*=","/=","%=","^=","&=","|=","<<=",">>="};

                for (int d = 2; d <= 4; d++)
                {
                    if (d != 2)
                        next_line();

                    decorative_section(make_str("vec", d), [&]
                    {
                        for (auto op : ops2)
                        {
                            bool all_of = (op == std::string("==")),
                                 any_of = (op == std::string("!=")),
                                 boolean = all_of || any_of;

                            // vec @ vec
                            output("template <typename A, typename B> [[nodiscard]] constexpr ",(boolean ? "bool" : "auto")," operator",op,"(const vec",d,"<A> &a, const vec",d,"<B> &b)",
                                   (boolean ? "" : make_str(" -> vec",d,"<decltype(a.x ",op," b.x)>"))," {return ",(boolean ? "" : "{"));
                            for (int i = 0; i < d; i++)
                            {
                                if (i != 0)
                                    output(all_of ? " && " :
                                           any_of ? " || " : ", ");
                                output("a.",data::fields[i]," ",op," b.", data::fields[i]);
                            }
                            output((boolean ? "" : "}"),";}\n");

                            // vec @ scalar
                            output("template <typename V, typename S, typename = enable_if_scalar_t<S>> [[nodiscard]] constexpr ",(boolean ? "bool" : "auto")," operator",op,"(const vec",d,"<V> &v, const S &s) {return v ",op," vec",d,"<S>(s);}\n");

                            // scalar @ vec
                            output("template <typename S, typename V, typename = enable_if_scalar_t<S>> [[nodiscard]] constexpr ",(boolean ? "bool" : "auto")," operator",op,"(const S &s, const vec",d,"<V> &v) {return vec",d,"<S>(s) ",op," v;}\n");
                        }

                        for (auto op : ops2bool)
                        {
                            // vec @ vec
                            output("template <typename A, typename B> [[nodiscard]] constexpr bool operator",op,"(const vec",d,"<A> &a, const vec",d,"<B> &b) {return bool(a) ",op," bool(b);}\n");

                            // vec @ any
                            output("template <typename A, typename B> [[nodiscard]] constexpr bool operator",op,"(const vec",d,"<A> &a, const B &b) {return bool(a) ",op," bool(b);}\n");

                            // any @ vec
                            output("template <typename A, typename B> [[nodiscard]] constexpr bool operator",op,"(const A &a, const vec",d,"<B> &b) {return bool(a) ",op," bool(b);}\n");
                        }

                        for (auto op : ops1)
                        {
                            // @ vec
                            output("template <typename T> [[nodiscard]] constexpr auto operator",op,"(const vec",d,"<T> &v) -> vec",d,"<decltype(",op,"v.x)> {return {");
                            for (int i = 0; i < d; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(op, "v.", data::fields[i]);
                            }
                            output("};}\n");
                        }

                        for (auto op : ops1bool)
                        {
                            // @ vec
                            output("template <typename T> [[nodiscard]] constexpr bool operator",op,"(const vec",d,"<T> &v) {return ",op,"bool(v);}\n");
                        }

                        for (auto op : ops1incdec)
                        {
                            // @ vec
                            output("template <typename T> constexpr vec",d,"<T> &operator",op,"(vec",d,"<T> &v) {");
                            for (int i = 0; i < d; i++)
                                output(op,"v.",data::fields[i],"; ");
                            output("return v;}\n");

                            // vec @
                            output("template <typename T> constexpr vec",d,"<T> operator",op,"(vec",d,"<T> &v, int) {return {");
                            for (int i = 0; i < d; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output("v.",data::fields[i],op);
                            }
                            output("};}\n");
                        }

                        for (auto op : ops2as)
                        {
                            // vec @ vec
                            output("template <typename A, typename B> constexpr vec",d,"<A> &operator",op,"(vec",d,"<A> &a, const vec",d,"<B> &b) {");
                            for (int i = 0; i < d; i++)
                                output("a.",data::fields[i]," ",op," b.",data::fields[i],"; ");
                            output("return a;}\n");

                            // vec @ scalar
                            output("template <typename V, typename S, typename = enable_if_scalar_t<S>> constexpr vec",d,"<V> &operator",op,"(vec",d,"<V> &v, const S &s) {return v ",op," vec",d,"<S>(s);}\n");
                        }
                    });
                }

                next_line();

                decorative_section("input/output", [&]
                {
                    output(
                    R"( template <typename A, typename B, int D, typename T> std::basic_ostream<A,B> &operator<<(std::basic_ostream<A,B> &s, const vec<D,T> &v)
                        {
                            s.width(0);
                            s << '[';
                            for (int i = 0; i < D; i++)
                            {
                                if (i != 0)
                                $   s << ',';
                                s << v[i];
                            }
                            s << ']';
                            return s;
                        }
                        template <typename A, typename B, int W, int H, typename T> std::basic_ostream<A,B> &operator<<(std::basic_ostream<A,B> &s, const mat<W,H,T> &v)
                        {
                            s.width(0);
                            s << '[';
                            for (int y = 0; y < H; y++)
                            {
                                if (y != 0)
                                $   s << ';';
                                for (int x = 0; x < W; x++)
                                {
                                    if (x != 0)
                                    $   s << ',';
                                    s << v[x][y];
                                }
                            }
                            s << ']';
                            return s;
                        }
                        template <typename A, typename B, int D, typename T> std::basic_istream<A,B> &operator>>(std::basic_istream<A,B> &s, vec<D,T> &v)
                        {
                            s.width(0);
                            for (int i = 0; i < D; i++)
                            $   s >> v[i];
                            return s;
                        }
                        template <typename A, typename B, int W, int H, typename T> std::basic_istream<A,B> &operator>>(std::basic_istream<A,B> &s, mat<W,H,T> &v)
                        {
                            s.width(0);
                            for (int y = 0; y < H; y++)
                            for (int x = 0; x < W; x++)
                            $   s >> v[x][y];
                            return s;
                        }
                    )");
                });

                next_line();

                decorative_section("matrix multiplication", [&]
                {
                    auto Matrix = [&](int x, int y, std::string t) -> std::string
                    {
                        if (x == 1 && y == 1)
                            return t;
                        if (x == 1)
                            return make_str("vec",y,"<",t,">");
                        if (y == 1)
                            return make_str("vec",x,"<",t,">");
                        return make_str("mat",x,"x",y,"<",t,">");
                    };
                    auto Field = [&](int x, int y, int w, int h) -> std::string
                    {
                        if (w == 1 && h == 1)
                            return "";
                        if (w == 1)
                            return data::fields[y];
                        if (h == 1)
                            return data::fields[x];
                        return make_str(data::fields[x], ".", data::fields[y]);
                    };

                    for (int w2 = 1; w2 <= 4; w2++)
                    for (int h1 = 1; h1 <= 4; h1++)
                    for (int w1h2 = 2; w1h2 <= 4; w1h2++) // Starting from 1 would generate `vec * vec` templates (outer products), which would conflict with member-wise multiplication.
                    {
                        if (w2 == 1 && h1 == 1) // This disables generation of `vec * vec` templates (dot products), which would conflict with member-wise multiplication.
                            continue;
                        output("template <typename A, typename B> [[nodiscard]] constexpr ",Matrix(w2,h1,"larger_t<A,B>")," operator*(const ",Matrix(w1h2,h1,"A")," &a, const ",Matrix(w2,w1h2,"B")," &b) {return {");
                        for (int y = 0; y < h1; y++)
                        for (int x = 0; x < w2; x++)
                        {
                            if (y != 0 || x != 0)
                                output(", ");
                            for (int j = 0; j < w1h2; j++)
                            {
                                if (j != 0)
                                    output(" + ");
                                output("a.",Field(j,y,w1h2,h1),"*b.",Field(x,j,w2,w1h2));
                            }
                        }
                        output("};}\n");
                    }

                    next_line();

                    // Only in those two cases return type matches the type of the first parameter.
                    output("template <typename A, typename B, int D> constexpr vec<D,A> &operator*=(vec<D,A> &a, const mat<D,D,B> &b) {a = a * b; return a;}\n");
                    output("template <typename A, typename B, int W, int H> constexpr mat<W,H,A> &operator*=(mat<W,H,A> &a, const mat<W,W,B> &b) {a = a * b; return a;}\n"); // `mat<W,W,B>` is not a typo!
                });
            });
        });

        next_line();

        section("inline namespace CustomOperators", []
        {
            const std::string
                symbol = "/",
                ops[]{"dot","cross"};

            for (auto op : ops)
                output("inline constexpr struct op_type_",op," {} ",op,";\n");

            next_line();

            for (auto op : ops)
            {
                output(1+R"(
                    template <typename A> struct op_expr_type_)",op,R"(
                    {
                        A &&a;
                        template <typename B> [[nodiscard]] constexpr decltype(auto) operator)",symbol,R"((B &&b) {return std::forward<A>(a).)",op,R"((std::forward<B>(b));}
                        template <typename B> constexpr decltype(auto) operator)",symbol,R"(=(B &&b) {a = std::forward<A>(a).)",op,R"((std::forward<B>(b)); return std::forward<A>(a);}
                    };
                )");
            }

            next_line();

            for (auto op : ops)
                output("template <typename T> inline constexpr op_expr_type_",op,"<T> operator",symbol,"(T &&param, op_type_",op,") {return {std::forward<T>(param)};}\n");

        });

        next_line();

        section("inline namespace Utility // Member access", []
        {
            output(1+R"(
                template <int I, typename T> constexpr auto &get_vec_element(T &&vec)
                {
                    // Returns a non-const reference only if the parameter is a non-const lvalue; otherwise returns a const reference.
                    static_assert(I >= 0 && I < 4);
                    constexpr bool not_const = std::is_reference_v<T> && !std::is_const_v<std::remove_reference_t<T>>;
                    if constexpr (!is_vector_v<std::remove_reference_t<T>>)
                    $   return std::conditional_t<not_const, T &, const T &>(vec);
                    else
                    $   return std::conditional_t<not_const, vec_base_t<std::remove_reference_t<T>> &, const vec_base_t<std::remove_reference_t<T>> &>(vec.template get<I>());
                }

                template <int D, typename F> constexpr void cexpr_for(F &&func)
                {
                    static_assert(D >= 1 && D <= 4);
            )");
            for (int i = 0; i < 4; i++)
            {
                if (i >= 1)
                    output("if constexpr (D > ",i,") ");
                output("func(std::integral_constant<int,",i,">{});\n");
            }
            output(1+R"(
                }
            )");
        });

        next_line();

        section("inline namespace Misc", []
        {
            output(1+R"(
                template <typename F, typename ...P> constexpr auto apply_elementwise(F &&func, P &&... params)
                {
                    using larger_type = opt_larger_t<change_vec_base_t<std::remove_reference_t<P>, int>...>;
                    static_assert(!std::is_void_v<larger_type>, "Parameter size mismatch.");
                    constexpr int size = vec_size_v<larger_type>;

                    using ret_type = decltype(std::declval<F>()(get_vec_element<0>(std::declval<P>())...));

                    if constexpr (std::is_void_v<ret_type>)
                    {
                        cexpr_for<size>([&](auto index)
                        {
                            func(get_vec_element<index.value>(params)...); // No forwarding to prevent moving.
                        });
                        return void();
                    }
                    else
                    {
                        std::conditional_t<size != 1, vec<size, ret_type>, ret_type> ret{};
                        cexpr_for<size>([&](auto index)
                        {
                            get_vec_element<index.value>(ret) = func(get_vec_element<index.value>(params)...); // No forwarding to prevent moving.
                        });
                        return ret;
                    }
                }

                template <typename T> [[nodiscard]] constexpr T pi() {return T(3.14159265358979323846l);}
                constexpr float       f_pi  = pi<float>();
                constexpr double      d_pi  = pi<double>();
                constexpr long double ld_pi = pi<long double>();

                template <typename T> [[nodiscard]] constexpr auto to_rad(T in)
                {
                    using fp_t = floating_point_t<T>;
                    return in * pi<fp_t>() / fp_t(180);
                }
                template <typename T> [[nodiscard]] constexpr auto to_deg(T in)
                {
                    using fp_t = floating_point_t<T>;
                    return in * fp_t(180) / pi<fp_t>();
                }

                template <typename T> [[nodiscard]] constexpr change_vec_base_t<T,int> sign(T val)
                {
                    // Works on scalars and vectors.
                    return (val > 0) - (val < 0);
                }

                template <typename A, typename B> constexpr void clamp_var_min(A &var, B min)
                {
                    static_assert(no_vectors_v<B> || is_vector_v<A>, "If `min` is a vector, `var` has to be a vector as well.");

                    if constexpr (no_vectors_v<A,B>)
                    {
                        if (var < min)
                            var = min;
                    }
                    else
                    {
                        apply_elementwise(clamp_var_min<vec_base_t<A>, vec_base_t<B>>, var, min);
                    }
                }

                template <typename A, typename B> constexpr void clamp_var_max(A &var, B max)
                {
                    static_assert(no_vectors_v<B> || is_vector_v<A>, "If `max` is a vector, `var` has to be a vector as well.");

                    if constexpr (no_vectors_v<A,B>)
                    {
                        if (var > max)
                            var = max;
                    }
                    else
                    {
                        apply_elementwise(clamp_var_max<vec_base_t<A>, vec_base_t<B>>, var, max);
                    }
                }

                template <typename A, typename B, typename C> constexpr void clamp_var(A &var, B min, C max)
                {
                    clamp_var_min(var, min);
                    clamp_var_max(var, max);
                }

                template <typename A, typename B> [[nodiscard]] constexpr A clamp_min(A val, B min)
                {
                    clamp_var_min(val, min);
                    return val;
                }

                template <typename A, typename B> [[nodiscard]] constexpr A clamp_max(A val, B max)
                {
                    clamp_var_max(val, max);
                    return val;
                }

                template <typename A, typename B, typename C> [[nodiscard]] constexpr A clamp(A val, B min, C max)
                {
                    clamp_var(val, min, max);
                    return val;
                }

                template <typename A> [[nodiscard]] constexpr A clamp(A val) {return clamp(val, 0, 1);}
                template <typename A> [[nodiscard]] constexpr A clamp_min(A val) {return clamp_min(val, 0);}
                template <typename A> [[nodiscard]] constexpr A clamp_max(A val) {return clamp_max(val, 1);}
                template <typename A> constexpr void clamp_var(A &var) {clamp_var(var, 0, 1);}
                template <typename A> constexpr void clamp_var_min(A &var) {clamp_var_min(var, 0);}
                template <typename A> constexpr void clamp_var_max(A &var) {clamp_var_max(var, 1);}

                template <typename I = int, typename F> [[nodiscard]] change_vec_base_t<F,I> iround(F x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<F>>, "Argument must be floating-point.");
                    static_assert(std::is_integral_v<I> && std::is_signed_v<I>, "Template argument must be integral and signed.");

                    if constexpr(no_vectors_v<F>)
                    {
                        if constexpr (sizeof (I) <= sizeof (long))
                        $   return std::lround(x);
                        else
                        $   return std::llround(x);
                    }
                    else
                    {
                        return apply_elementwise(iround<I, vec_base_t<F>>, x);
                    }
                }

                template <typename T> [[nodiscard]] T abs(T x)
                {
                    if constexpr (no_vectors_v<T>)
                    $   return std::abs(x);
                    else
                    $   return apply_elementwise(abs<vec_base_t<T>>, x);
                }

                template <typename T> [[nodiscard]] T round(T x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");

                    if constexpr (no_vectors_v<T>)
                    $   return std::round(x);
                    else
                    $   return apply_elementwise(round<vec_base_t<T>>, x);
                }

                template <typename T> [[nodiscard]] T floor(T x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");

                    if constexpr (no_vectors_v<T>)
                    $   return std::floor(x);
                    else
                    $   return apply_elementwise(floor<vec_base_t<T>>, x);
                }

                template <typename T> [[nodiscard]] T ceil(T x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");

                    if constexpr (no_vectors_v<T>)
                    $   return std::ceil(x);
                    else
                    $   return apply_elementwise(ceil<vec_base_t<T>>, x);
                }

                template <typename T> [[nodiscard]] T trunc(T x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");

                    if constexpr (no_vectors_v<T>)
                    $   return std::trunc(x);
                    else
                    $   return apply_elementwise(trunc<vec_base_t<T>>, x);
                }

                template <typename T> [[nodiscard]] T frac(T x)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");

                    if constexpr (no_vectors_v<T>)
                    $   return std::modf(x, 0);
                    else
                    $   return apply_elementwise(frac<vec_base_t<T>>, x);
                }

                template <typename A, typename B> [[nodiscard]] constexpr A div_ex(A a, B b)
                {
                    static_assert(no_vectors_v<B> || is_vector_v<A>, "If `b` is a vector, `a` has to be a vector as well.");
                    static_assert(std::is_integral_v<vec_base_t<A>> && std::is_integral_v<vec_base_t<B>>, "Arguments must be integral.");

                    if constexpr (no_vectors_v<A,B>)
                    {
                        if (a >= 0)
                        $   return a / b;
                        else
                        $   return (a + 1) / b - sign(b);
                    }
                    else
                    {
                        return apply_elementwise(div_ex<vec_base_t<A>, vec_base_t<B>>, a, b);
                    }
                }

                template <typename A, typename B> [[nodiscard]] constexpr A mod_ex(A a, B b)
                {
                    static_assert(no_vectors_v<B> || is_vector_v<A>, "If `b` is a vector, `a` has to be a vector as well.");
                    static_assert(std::is_integral_v<vec_base_t<A>> && std::is_integral_v<vec_base_t<B>>, "Arguments must be integral.");

                    if constexpr (no_vectors_v<A,B>)
                    {
                        if (a >= 0)
                        $   return a % b;
                        else
                        $   return abs(b) - 1 + (a + 1) % b;
                    }
                    else
                    {
                        return apply_elementwise(mod_ex<vec_base_t<A>, vec_base_t<B>>, a, b);
                    }
                }

                template <typename A, typename B> [[nodiscard]] constexpr A ipow(A a, B b)
                {
                    // `A` can be a scalar or a vector. `B` has to be scalar.
                    static_assert(std::is_integral_v<B>, "Power must be integral.");
                    A ret = 1;
                    while (b-- > 0)
                    $   ret *= a;
                    return ret;
                }

                template <typename A, typename B> [[nodiscard]] constexpr floating_point_t<larger_t<A,B>> pow(A a, B b)
                {
                    if constexpr (no_vectors_v<A,B>)
                    $   return std::pow(a, b);
                    else
                    $   return apply_elementwise(pow<vec_base_t<A>, vec_base_t<B>>, a, b);
                }

                template <typename T> [[nodiscard]] constexpr T smoothstep(T x)
                {
                    // Works on scalars and vectors.
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Argument must be floating-point.");
                    return (3 - 2*x) * x*x;
                }

                template <typename ...P> constexpr larger_t<P...> min(P ... params)
                {
                    if constexpr (no_vectors_v<P...>)
                    $   return std::min({larger_t<P...>(params)...});
                    else
                    $   return apply_elementwise(min<vec_base_t<P>...>, params...);
                }

                template <typename ...P> constexpr larger_t<P...> max(P ... params)
                {
                    if constexpr (no_vectors_v<P...>)
                    $   return std::max({larger_t<P...>(params)...});
                    else
                    $   return apply_elementwise(max<vec_base_t<P>...>, params...);
                }

                template <typename T> struct linear_mapping
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Template parameter must be floating-point.");

                    T scale = T(1), offset = T(0);

                    linear_mapping() = default;

                    linear_mapping(T src_a, T src_b, T dst_a, T dst_b)
                    {
                        T factor = 1 / (src_a - src_b);
                        scale = (dst_a - dst_b) * factor;
                        offset = (dst_b * src_a - dst_a * src_b) * factor;
                    }

                    T operator()(T x) const
                    {
                        return x * scale + offset;
                    }

                    using matrix_t = mat<vec_size_v<T>+1, vec_size_v<T>+1, vec_base_t<T>>;
                    matrix_t matrix() const
                    {
                        matrix_t ret{};
                        for (int i = 0; i < vec_size_v<T>; i++)
                        {
                            ret[i][i] = scale[i];
                            ret[vec_size_v<T>][i] = offset[i];
                        }
                        return ret;
                    }
                };

                template <typename T> vec2<T> intersection_point(vec2<T> a1, vec2<T> a2, vec2<T> b1, vec2<T> b2)
                {
                    static_assert(std::is_floating_point_v<vec_base_t<T>>, "Arguments must be floating-point.");
                    auto delta_a = a2 - a1;
                    auto delta_b = b2 - b1;
                    return ((a1.y - b1.y) * delta_b.x - (a1.x - b1.x) * delta_b.y) / (delta_a.x * delta_b.y - delta_a.y * delta_b.x) * delta_a + a1;
                }
            )");
        });

        next_line();

        section("namespace Export", []
        {
            output(1+R"(
                using namespace Vector;
                using namespace CustomOperators;
                using namespace Misc;

                using std::int8_t;
                using std::uint8_t;
                using std::int16_t;
                using std::uint16_t;
                using std::int32_t;
                using std::uint32_t;
                using std::int64_t;
                using std::uint64_t;
                using std::size_t;
                using std::ptrdiff_t;

                using std::sqrt;
                using std::cos;
                using std::sin;
                using std::tan;
                using std::acos;
                using std::asin;
                using std::atan;
                using std::atan2;
            )");
        });
    });

    next_line();

    section("namespace std", []
    {
        output(1+R"(
            template <int D, typename T> struct less<Math::vec<D,T>>
            {
                using result_type = bool;
                using first_argument_type = Math::vec<D,T>;
                using second_argument_type = Math::vec<D,T>;
                constexpr bool operator()(const Math::vec<D,T> &a, const Math::vec<D,T> &b) const
                {
                    return a.tie() < b.tie();
                }
            };

            template <int D, typename T> struct hash<Math::vec<D,T>>
            {
                using result_type = std::size_t;
                using argument_type = Math::vec<D,T>;
                std::size_t operator()(const Math::vec<D,T> &v) const
                {
                    std::size_t ret = std::hash<decltype(v.x)>{}(v.x);
                    for (int i = 1; i < D; i++)
                    $   ret ^= std::hash<decltype(v.x)>{}(v[i]) + 0x9e3779b9 + (ret << 6) + (ret >> 2); // From Boost.
                    return ret;
                }
            };
        )");
    });

    next_line();

    output("using namespace Math::Export;\n");

    next_line();

    if (!impl::output_file)
        return -1;
}
